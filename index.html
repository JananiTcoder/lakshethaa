<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>AR Image Replacement</title>
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<style>
  body { margin:0; background:black; overflow:hidden; }
  canvas { width:100vw; height:100vh; object-fit:cover; display:block; }
  #videoSource, #videoCanvas { display:none; }
</style>
</head>
<body>

<video id="videoSource" src="output.mp4" autoplay loop muted playsinline></video>
<canvas id="videoCanvas"></canvas>

<video id="camera" autoplay playsinline muted style="display:none;"></video>
<canvas id="canvas"></canvas>
<img id="referenceImg" src="reference.jpg" style="display:none;">

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const camera = document.getElementById('camera');
const videoSource = document.getElementById('videoSource');
const videoCanvas = document.getElementById('videoCanvas');
const videoCtx = videoCanvas.getContext('2d');
const refImg = document.getElementById('referenceImg');

// Start back camera
navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: false })
  .then(stream => camera.srcObject = stream)
  .catch(err => console.error(err));

cv['onRuntimeInitialized'] = () => {
    let refColor = cv.imread(refImg);
    let refGray = new cv.Mat();
    cv.cvtColor(refColor, refGray, cv.COLOR_BGR2GRAY);

    let orb = new cv.ORB();
    let kpRef = new cv.KeyPointVector();
    let descRef = new cv.Mat();
    orb.detectAndCompute(refGray, new cv.Mat(), kpRef, descRef);

    const bf = new cv.BFMatcher(cv.NORM_HAMMING);

    function process() {
        if(camera.readyState !== 4) { requestAnimationFrame(process); return; }

        canvas.width = camera.videoWidth;
        canvas.height = camera.videoHeight;
        ctx.drawImage(camera,0,0,canvas.width,canvas.height);
        let frame = cv.imread(canvas);
        let grayFrame = new cv.Mat();
        cv.cvtColor(frame, grayFrame, cv.COLOR_BGR2GRAY);

        let kpFrame = new cv.KeyPointVector();
        let descFrame = new cv.Mat();
        orb.detectAndCompute(grayFrame, new cv.Mat(), kpFrame, descFrame);

        if(!descFrame.empty()) {
            let matched = new cv.DMatchVector();
            bf.match(descRef, descFrame, matched);

            let goodMatches = [];
            for(let i=0;i<matched.size();i++){
                if(matched.get(i).distance < 60) goodMatches.push(matched.get(i));
            }

            if(goodMatches.length >= 10){
                // Compute homography
                let srcPts = [];
                let dstPts = [];
                for(let i=0;i<goodMatches.length;i++){
                    srcPts.push(kpRef.get(goodMatches[i].queryIdx).pt.x);
                    srcPts.push(kpRef.get(goodMatches[i].queryIdx).pt.y);
                    dstPts.push(kpFrame.get(goodMatches[i].trainIdx).pt.x);
                    dstPts.push(kpFrame.get(goodMatches[i].trainIdx).pt.y);
                }
                let srcMat = cv.matFromArray(goodMatches.length,1,cv.CV_32FC2,srcPts);
                let dstMat = cv.matFromArray(goodMatches.length,1,cv.CV_32FC2,dstPts);
                let mask = new cv.Mat();
                let H = cv.findHomography(srcMat,dstMat,cv.RANSAC,5,mask);

                if(!H.empty()){
                    // Draw current video frame to hidden canvas
                    videoCanvas.width = videoSource.videoWidth;
                    videoCanvas.height = videoSource.videoHeight;
                    videoCtx.drawImage(videoSource,0,0,videoCanvas.width,videoCanvas.height);
                    let vidFrame = cv.imread(videoCanvas);

                    let warped = new cv.Mat();
                    let dsize = new cv.Size(frame.cols, frame.rows);
                    cv.warpPerspective(vidFrame, warped, H, dsize);

                    // Overlay video on camera frame
                    cv.addWeighted(warped,1.0,frame,0,0,frame);
                    cv.imshow(canvas, frame);

                    vidFrame.delete();
                    warped.delete();
                    H.delete();
                    srcMat.delete();
                    dstMat.delete();
                    mask.delete();
                }
            }

            matched.delete();
        }

        frame.delete();
        grayFrame.delete();
        kpFrame.delete();
        descFrame.delete();

        requestAnimationFrame(process);
    }

    process();
};
</script>
</body>
</html>
